Con gusto. A continuaci√≥n te presento un **material did√°ctico formal** sobre **Uso pr√°ctico de `std::unique_ptr` y `std::shared_ptr` en clases**, ideal para estudiantes que ya conocen la sem√°ntica de copia y movimiento y est√°n avanzando en la gesti√≥n moderna de recursos en C++.

---

# üìò Uso pr√°ctico de `std::unique_ptr` y `std::shared_ptr` en clases

---

## üéØ Prop√≥sito

En programas complejos, la gesti√≥n manual de memoria es propensa a errores y fugas. El uso de **punteros inteligentes** permite delegar la liberaci√≥n de memoria al sistema de tipos, reduciendo errores y simplificando la l√≥gica de destrucci√≥n.

Este apartado se enfoca en el **uso pr√°ctico** de `std::unique_ptr` y `std::shared_ptr` como miembros de clases, explicando cu√°ndo usar cada uno, c√≥mo gestionar la propiedad y c√≥mo implementar clases RAII robustas.

---

## üß† Conceptos clave

### `std::unique_ptr<T>`

* Representa **propiedad exclusiva** de un recurso.
* No se puede copiar, solo mover.
* Ideal para:

  * Composici√≥n interna (atributos de una clase)
  * Propiedad clara y no compartida

### `std::shared_ptr<T>`

* Representa **propiedad compartida**.
* Se puede copiar; mantiene un contador de referencias.
* Ideal para:

  * Recursos compartidos entre m√∫ltiples objetos
  * √Årboles con punteros padre-hijo
  * Callbacks o almacenamiento en contenedores heterog√©neos

---

## üß± Ejemplo 1: Uso de `std::unique_ptr` en composici√≥n

```cpp
#include <iostream>
#include <memory>

class Motor {
public:
    void arrancar() { std::cout << "Motor en marcha\n"; }
};

class Coche {
public:
    Coche() : motor_(std::make_unique<Motor>()) {}

    void iniciar() {
        motor_->arrancar();
    }

private:
    std::unique_ptr<Motor> motor_; // Composici√≥n exclusiva
};
```

### ‚úÖ Explicaci√≥n

* `motor_` es de tipo `std::unique_ptr<Motor>`, lo que garantiza que el `Coche` es due√±o √∫nico del `Motor`.
* No hay necesidad de definir un destructor manual: el `unique_ptr` libera el recurso autom√°ticamente.
* La clase no es copiable por defecto, lo cual **refuerza la unicidad de la propiedad**.

---

## üß± Ejemplo 2: Uso de `std::shared_ptr` para propiedad compartida

```cpp
#include <iostream>
#include <memory>
#include <vector>

class Documento {
public:
    Documento(const std::string& texto) : texto_(texto) {}
    void imprimir() const { std::cout << texto_ << '\n'; }

private:
    std::string texto_;
};

class Usuario {
public:
    Usuario(std::shared_ptr<Documento> doc) : doc_(doc) {}
    void leer() const { doc_->imprimir(); }

private:
    std::shared_ptr<Documento> doc_;
};
```

```cpp
int main() {
    auto documento = std::make_shared<Documento>("Contenido compartido");

    Usuario u1(documento);
    Usuario u2(documento); // Ambos comparten el documento

    u1.leer();
    u2.leer(); // El documento sigue existiendo
}
```

### ‚úÖ Explicaci√≥n

* `documento` es un recurso compartido entre m√∫ltiples instancias de `Usuario`.
* El uso de `std::shared_ptr` permite que varios objetos compartan el mismo recurso, y que este se destruya autom√°ticamente cuando ya nadie lo necesita.
* Es especialmente √∫til en estructuras **grafo-like**, **modelos vista-controlador** o cuando se desea pasar recursos sin transferir la propiedad exclusiva.

---

## üß® Buenas pr√°cticas y advertencias

| Pr√°ctica recomendada                         | Evitar                                    |
| -------------------------------------------- | ----------------------------------------- |
| Usar `std::unique_ptr` para propiedad clara  | Copiar `unique_ptr` (no compila)          |
| Usar `std::make_unique` / `std::make_shared` | Usar `new` y `delete` manualmente         |
| Pasar `unique_ptr` por valor o moverlo       | Guardar punteros brutos sin justificaci√≥n |
| Evitar ciclos con `shared_ptr`               | Ciclos sin `weak_ptr` ‚Üí fuga de memoria   |

---

## üß© Conclusi√≥n

* `std::unique_ptr` y `std::shared_ptr` son herramientas esenciales para gestionar recursos din√°micos en clases de manera segura.
* Usarlas correctamente facilita el cumplimiento del principio RAII y mejora la **robustez, claridad y mantenibilidad** del c√≥digo.
* La elecci√≥n entre uno y otro depende de la **sem√°ntica de propiedad** del recurso que representa.

---

¬øTe gustar√≠a que el siguiente apartado ("Clonaci√≥n de objetos") parta de estos ejemplos y muestre c√≥mo implementar copias profundas y superficiales correctamente con punteros inteligentes?
